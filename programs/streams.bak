#lang racket
; LAZY potoci i spisaci
; bezkraini potoci i spisaci
; map, filter i t.n. varhu bezkraini potoci

;(delay <
;   spisaci                streams
;    `()                     empty-stream
;    cons                   stream-cons
;   null?                   stream-empty?
;   length                  stream-length
;   list-ref                stream-ref
;   append                  stream-append
;   car                     stream-first
;   cdr                     stream-rest
;   list                    stream
;   map                     streasm-map
;  filter                   stream-filter

; stream->list

;(enum start end)
;(list-to-stream l)
;(stream-to-list s)
; repeat-list l
; repeat-lists l1 l1
; cartesian-product A1 A2


(define symb 2)
(define sum12 (delay (+ symb 2)))
(set! symb 3)
(force sum12)
empty-stream
(stream 1 2 3)
(stream->list (stream 1 2 3))


(define (enum start end)
  (define (helper stream crr)
    (if (= (- start 1) crr)
        stream
        (helper (stream-cons crr stream) (- crr 1))
    )
   )
  (helper empty-stream end)
 )

(stream->list(enum 2 5))
(define (stream-to-list strim)
  (define (helper crrstrm crrlst)
    (if (stream-empty? crrstrm)
        crrlst
        (helper (stream-rest crrstrm) (append crrlst (list (stream-first crrstrm))))
     )
   )
  (helper strim `())
)
(stream-to-list (enum 2 5))
; list-to-stream -DOMASHNO
(define (stream-take s n)
  (define (helper crrtaken crrlst crrstrm)
    (if (= crrtaken n)
        crrlst
        (helper (+ crrtaken 1) (append crrlst (list (stream-first crrstrm))) (stream-rest crrstrm))
      )
   )
  (helper 0 `() s)
 )
(define (stream-take-rec s n)
  (if (= n 0)
      `()
      (cons (stream-first s) (stream-take-rec (stream-rest s) (- n 1)))))

(stream-take (enum 2 9) 5)

(define (add-streams s1 s2)
  (if (or (stream-empty? s1) (stream-empty? s2))
      empty-stream
      (stream-cons (+ (stream-first s1) (stream-first s2)) (add-streams (stream-rest s1) (stream-rest s2)))
    )
 )
(stream-to-list (add-streams (stream 1 2 3 4 5 6) (stream 2 3 4 5 6 7)))


(define (n-stream)
  (define (helper n)
    (stream-cons n (helper (+ n 1)))
   )
  (helper 0)
 )


(stream-take (n-stream) 10)
(stream-take-rec (n-stream) 10)

(stream-take(add-streams (n-stream) (n-stream)) 10)

(define (negative-n-stream)
  (map (lambda (x) (* x -1)))
 )

(define (isPrime? x)
  (define (isNotDivisible? r)
    (define (helper crr)
      (if (= crr 1)
          #t
          (and (not (= (remainder r crr) 0)) (helper (- crr 1))))
     )
    (helper (- r 1))
  )
  (if (or (= 0 x) (= 1 x))
      #f
      (isNotDivisible? x)
   )
 )
    
(define (prime-stream)
  (stream-filter (lambda (x) (isPrime? x)) (n-stream)))


(define (fibonacci-stream)
  (define (helper crrPrev crrPrevPrev)
    (stream-cons (+ crrPrev crrPrevPrev) (helper (+ crrPrev crrPrevPrev) crrPrev))
   )
  (stream-cons 1 (stream-cons 1 (helper 1 1)))
 )